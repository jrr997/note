# 递归

## 什么是递归？

例子：带女朋友去看电影，女朋友问我们正坐在第几排？因为电影院太黑，无法数排数。因此我问前面的人坐在第几排，我所在的排数 = 前面的人的排数 + 1。前面的人也问他前面的人，直到问到第一排的人，第一排的人回答1，然后一排排地把座位排数传回来。
这是一个标准的递归求解问题的分解过程。向前问排数的过程是‘递’，答案从前往后传的过程是‘归’。**所有递归问题基本都可以用递归公式表示**，这个例子的递归公式是：
$$
f(n) = f(n-1) + 1，其中f(1) = 1
$$
把递归公式翻译成代码：
```javascript
function f(n) {
	if (n === 1) return
	return f(n - 1) + 1
}
```

## 递归需要满足的三个条件

1. 待求解问题可以分解为几个子问题。
2. 待求解问题和子问题的求解思路相同。
3. 存在递归终止条件。

## 如何编写递归代码
1. 大问题分解成小问题，找到递归终止条件。
2. 写出递归公式，把递归公式翻译成代码。
注意：不要用人脑去分解递归的每个步骤，不要一层一层地往下思考子问题和子问题之间的关系。

## 递归代码的特点
使用递归编程有利有弊。好处是递归代码表达能力强，因此看起来非常简洁。缺点是递归代码空间复杂度高，存在栈溢出和重复计算的问题。

## 递归的细节
#### 如何避免栈溢出？
1. 限制递归深度
```javascript
let depth = 0
function f(n) {
	depth ++
	if(depth > 1000) return
	if (n === 1) return
	return f(n - 1) + 1
}
```
2. 将递归代码改写为非递归代码
```javascript
function f(n) {
	let res = 1
	for(let i = 1; i < n; i++) {
		res = res + 1
	}
	return res
}
```
如果我们自己实现堆栈来模拟函数调用栈，理论上可以把所有递归代码改成非递归代码，只是这样没意义，只是把自动递归改为‘手动递归’。’
3. 尾递归。在下一个二级标题中讲到。

#### 如何避免重复计算？
利用哈希表存储已计算过的结果。每次求解前先从哈希表中取结果，如果结果存在则return结果。如果结果不存在，开始计算结果，并在求解下一个子问题前把结果放入哈希表。

## 尾递归
递归为什么会产生堆栈溢出？
**函数调用**采用**函数调用栈**来保存现场(局部变量、返回地址等)。函数调用栈是内存的一块存储空间，被组织成‘栈’这种数据结构，数据(栈帧)先进后出。
返回地址是指将要执行的函数所在的内存地址。当执行完这个函数，返回上一个函数时时，通过返回地址可以知道函数目前执行到哪，下一步要执行哪个语句。
递归的过程包含大量的函数调用，如果递归求解的**数据规模很大**，**调用层次很深**，函数调用栈的栈帧就会变得大和多，而函数调用栈的空间一般不大，这个时候就存在堆栈溢出的风险。

**不是所有递归代码都能改写成为尾递归**。一般情况下，只有递归调用出现在函数的最后一行，并且没有任何局部变量参与最后一行代码的计算，这样的代码才能改写成尾递归。
```javascript
function f(n - 1, res) {
	if (n <= 1) return res
	return f(n - 1, n * res)
}
```
**尾递归有可能可以避免堆栈溢出**。上面的尾递归代码在进入下一个函数时，并不需要保存返回地址(因为没有往下执行的代码)，也没有局部变量需要保存，因此没有东西需要保存到函数调用栈，这样就不存在堆栈溢出的问题。之所以说**有可能**，是因为不是所有编程语言都支持尾递归优化。
在实际开发中，尾递归其实没有太大作用，具体的理由如下：
- 并不是所有的编程语言都支持尾递归优化；
- 并不是所有的递归都可以改成尾递归；
- 能改成尾递归的代码都可以改成迭代；
- 尾递归代码的可读性很差。